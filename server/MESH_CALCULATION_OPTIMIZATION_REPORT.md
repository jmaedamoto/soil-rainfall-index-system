# メッシュ計算処理最適化提案レポート

**作成日**: 2025年11月12日
**対象**: サーバー側メッシュ計算処理（約20秒のボトルネック）

---

## 📊 現状分析

### パフォーマンスプロファイリング結果

**総処理時間**: 36.09秒
**メッシュ数**: 26,045
**関数呼び出し数**: 105,860,094回

### ボトルネック詳細（メッシュ計算部分: 15.6秒）

| 関数 | 自己時間 | 呼び出し回数 | 累積時間 | 削減ポテンシャル |
|------|----------|-------------|----------|----------------|
| **calc_tunk_model** | **2.30秒** | **2,708,680回** | 2.30秒 | 高（270万回呼び出し） |
| calc_swi_hourly | 1.75秒 | 26,045回 | 4.50秒 | 中 |
| calc_hourly_rain | 1.89秒 | 26,045回 | 2.76秒 | 中 |
| calc_3hour_max_risk_from_hourly | 1.58秒 | 26,045回 | 2.32秒 | 中 |
| calc_hourly_risk | 1.55秒 | 26,045回 | 2.29秒 | 中 |
| calc_rain_timelapse | 1.50秒 | 52,090回 | 1.97秒 | 中 |

---

## 🚀 最適化戦略

### ❌ 試行済み・見送られた最適化

#### 1. 並列処理（マルチプロセス/スレッド）
**試行結果**: CLAUDE.mdに記載の通り、過去に調査済み

**見送り理由**:
- Windows環境でのmultiprocessing互換性問題
- Flask開発モードでのプロセスフォーク制約
- Python GIL（Global Interpreter Lock）の制約
- **費用対効果が低い**（実装の複雑性 vs 高速化効果）

**結論**: シンプルで安定したコードを優先

---

### ✅ 推奨最適化戦略

#### 戦略1: **キャッシュシステムの活用**（最優先・既に実装済み）

**現状**:
- 本番API（`/api/production-soil-rainfall-index`）で実装済み
- キャッシュヒット時: **18秒 → 5秒**（3.6倍高速化）
- gzip圧縮: 209MB → 5.24MB（97.4%削減）

**効果**:
- ✅ **最大の効果**: 計算処理をスキップ
- ✅ **安定性**: シンプルな実装
- ✅ **実装済み**: すぐに効果が出る

**提案**: テストデータAPIにもキャッシュを適用

```python
# services/main_service.py に追加
def main_process_from_files_cached(self, swi_file: str, guidance_file: str):
    # キャッシュキー生成（ファイル名ベース）
    cache_key = f"test_{os.path.basename(swi_file)}_{os.path.basename(guidance_file)}"

    # キャッシュチェック
    cached_result = self.cache_service.get_cached_result(cache_key)
    if cached_result:
        logger.info(f"キャッシュヒット: {cache_key}")
        return cached_result

    # キャッシュミス: 通常処理
    result = self.main_process_from_files(swi_file, guidance_file)

    # キャッシュ保存
    self.cache_service.set_cached_result(cache_key, result, ...)

    return result
```

**期待効果**: テストデータ取得が **30秒 → 5秒**（6倍高速化）

---

#### 戦略2: **GRIB2データの効率的再利用**

**現状の問題**:
- GRIB2解析: 約8秒（全体の22%）
- 同じ時刻のデータを複数回解析している可能性

**提案**: GRIB2データのメモリキャッシュ

```python
class Grib2Service:
    def __init__(self):
        self._grib2_cache = {}  # メモリキャッシュ

    def unpack_swi_grib2_from_file_cached(self, file_path: str):
        if file_path in self._grib2_cache:
            return self._grib2_cache[file_path]

        result = self.unpack_swi_grib2_from_file(file_path)
        self._grib2_cache[file_path] = result
        return result
```

**期待効果**: 同一ファイルの2回目以降の解析が**即座**に完了

---

#### 戦略3: **計算結果の段階的キャッシュ**

**アイデア**: 府県レベルでキャッシュ

```python
# 府県ごとにキャッシュ
cache_key = f"pref_{pref_code}_{swi_initial}_{guidance_initial}"
```

**メリット**:
- 部分的な再計算が可能
- キャッシュヒット率の向上
- メモリ効率の向上

---

### 🔍 将来的な最適化候補（慎重に検討）

#### 候補A: NumPyベクトル化（慎重に検討）

**対象**: `calc_tunk_model`（270万回呼び出し）

**リスク**:
- ⚠️ **VBA互換性の検証が必須**（100%一致を維持）
- ⚠️ 複雑性の増加
- ⚠️ デバッグの難易度上昇

**期待効果**: 2-3秒の削減可能性

**推奨**:
- まずキャッシュ最適化で効果を確認
- その後、必要に応じて慎重に実装
- **必ず完全な検証を実施**（`test_runlength_compare.py`のような検証）

---

#### 候補B: Cython/Numba によるJIT コンパイル

**対象**: `calc_tunk_model`

**メリット**:
- Pythonコードをほぼそのまま高速化
- VBA互換性を維持しやすい

**デメリット**:
- 追加の依存関係
- デプロイの複雑化

**推奨**: 慎重に検討、費用対効果を評価

---

## 📈 最適化優先度

### 優先度1（即実装推奨）: キャッシュシステムの拡張
- **効果**: 最大（6倍高速化）
- **リスク**: 最小（既存実装の応用）
- **工数**: 小（1-2時間）
- **ROI**: 極めて高い

### 優先度2（短期検討）: GRIB2メモリキャッシュ
- **効果**: 中（2-3秒削減）
- **リスク**: 小
- **工数**: 小（2-3時間）
- **ROI**: 高い

### 優先度3（中期検討）: NumPyベクトル化
- **効果**: 中（2-3秒削減）
- **リスク**: 中（VBA互換性検証が必須）
- **工数**: 中（1-2日）
- **ROI**: 中

### 優先度4（長期検討）: Cython/Numba
- **効果**: 中-大
- **リスク**: 中-高
- **工数**: 大
- **ROI**: 要検討

---

## 💡 推奨アクションプラン

### Phase 1: 即効対策（今日〜明日）
1. テストデータAPIにキャッシュシステムを適用
2. GRIB2メモリキャッシュの実装
3. **期待効果**: テストデータ取得 30秒 → 5-7秒

### Phase 2: 短期改善（今週）
1. 府県レベルキャッシュの実装
2. キャッシュヒット率の測定・分析
3. **期待効果**: さらに1-2秒の削減

### Phase 3: 中期改善（来月以降・必要に応じて）
1. NumPyベクトル化の実装（慎重に）
2. 完全な検証（約4.5億データポイント）
3. **期待効果**: 2-3秒の削減

---

## 🎯 結論

**最も効果的な最適化**: すでに実装済みの**キャッシュシステム**

**現在の状況**:
- 本番API: キャッシュあり（5秒）
- テストAPI: キャッシュなし（30秒） ← **ここを改善**

**推奨**:
1. ✅ テストAPIにキャッシュ適用（最優先）
2. ✅ GRIB2メモリキャッシュ追加
3. ⏸️ 並列処理は見送り（過去の判断を踏襲）
4. 🔍 NumPyベクトル化は慎重に検討（必要に応じて）

**期待される総合効果**:
- クライアント側計測: **30秒 → 5-7秒**（約5倍高速化）
- キャッシュヒット時: **30秒 → 5秒**（6倍高速化）

---

**次のステップ**: テストデータAPIへのキャッシュ適用実装を推奨します。
